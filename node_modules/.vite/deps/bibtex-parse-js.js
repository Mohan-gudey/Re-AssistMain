import {
  __commonJS
} from "./chunk-G3PMV62Z.js";

// node_modules/bibtex-parse-js/bibtexParse.js
var require_bibtexParse = __commonJS({
  "node_modules/bibtex-parse-js/bibtexParse.js"(exports) {
    (function(exports2) {
      function BibtexParser() {
        this.months = ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"];
        this.notKey = [",", "{", "}", " ", "="];
        this.pos = 0;
        this.input = "";
        this.entries = new Array();
        this.currentEntry = "";
        this.setInput = function(t) {
          this.input = t;
        };
        this.getEntries = function() {
          return this.entries;
        };
        this.isWhitespace = function(s) {
          return s == " " || s == "\r" || s == "	" || s == "\n";
        };
        this.match = function(s, canCommentOut) {
          if (canCommentOut == void 0 || canCommentOut == null)
            canCommentOut = true;
          this.skipWhitespace(canCommentOut);
          if (this.input.substring(this.pos, this.pos + s.length) == s) {
            this.pos += s.length;
          } else {
            throw "Token mismatch, expected " + s + ", found " + this.input.substring(this.pos);
          }
          ;
          this.skipWhitespace(canCommentOut);
        };
        this.tryMatch = function(s, canCommentOut) {
          if (canCommentOut == void 0 || canCommentOut == null)
            canCommentOut = true;
          this.skipWhitespace(canCommentOut);
          if (this.input.substring(this.pos, this.pos + s.length) == s) {
            return true;
          } else {
            return false;
          }
          ;
          this.skipWhitespace(canCommentOut);
        };
        this.matchAt = function() {
          while (this.input.length > this.pos && this.input[this.pos] != "@") {
            this.pos++;
          }
          ;
          if (this.input[this.pos] == "@") {
            return true;
          }
          ;
          return false;
        };
        this.skipWhitespace = function(canCommentOut) {
          while (this.isWhitespace(this.input[this.pos])) {
            this.pos++;
          }
          ;
          if (this.input[this.pos] == "%" && canCommentOut == true) {
            while (this.input[this.pos] != "\n") {
              this.pos++;
            }
            ;
            this.skipWhitespace(canCommentOut);
          }
          ;
        };
        this.value_braces = function() {
          var bracecount = 0;
          this.match("{", false);
          var start2 = this.pos;
          var escaped = false;
          while (true) {
            if (!escaped) {
              if (this.input[this.pos] == "}") {
                if (bracecount > 0) {
                  bracecount--;
                } else {
                  var end = this.pos;
                  this.match("}", false);
                  return this.input.substring(start2, end);
                }
                ;
              } else if (this.input[this.pos] == "{") {
                bracecount++;
              } else if (this.pos >= this.input.length - 1) {
                throw "Unterminated value";
              }
              ;
            }
            ;
            if (this.input[this.pos] == "\\" && escaped == false)
              escaped = true;
            else
              escaped = false;
            this.pos++;
          }
          ;
        };
        this.value_comment = function() {
          var str = "";
          var brcktCnt = 0;
          while (!(this.tryMatch("}", false) && brcktCnt == 0)) {
            str = str + this.input[this.pos];
            if (this.input[this.pos] == "{")
              brcktCnt++;
            if (this.input[this.pos] == "}")
              brcktCnt--;
            if (this.pos >= this.input.length - 1) {
              throw "Unterminated value:" + this.input.substring(start);
            }
            ;
            this.pos++;
          }
          ;
          return str;
        };
        this.value_quotes = function() {
          this.match('"', false);
          var start2 = this.pos;
          var escaped = false;
          while (true) {
            if (!escaped) {
              if (this.input[this.pos] == '"') {
                var end = this.pos;
                this.match('"', false);
                return this.input.substring(start2, end);
              } else if (this.pos >= this.input.length - 1) {
                throw "Unterminated value:" + this.input.substring(start2);
              }
              ;
            }
            if (this.input[this.pos] == "\\" && escaped == false)
              escaped = true;
            else
              escaped = false;
            this.pos++;
          }
          ;
        };
        this.single_value = function() {
          var start2 = this.pos;
          if (this.tryMatch("{")) {
            return this.value_braces();
          } else if (this.tryMatch('"')) {
            return this.value_quotes();
          } else {
            var k = this.key();
            if (k.match("^[0-9]+$"))
              return k;
            else if (this.months.indexOf(k.toLowerCase()) >= 0)
              return k.toLowerCase();
            else
              throw "Value expected:" + this.input.substring(start2) + " for key: " + k;
          }
          ;
        };
        this.value = function() {
          var values = [];
          values.push(this.single_value());
          while (this.tryMatch("#")) {
            this.match("#");
            values.push(this.single_value());
          }
          ;
          return values.join("");
        };
        this.key = function(optional) {
          var start2 = this.pos;
          while (true) {
            if (this.pos >= this.input.length) {
              throw "Runaway key";
            }
            ;
            if (this.notKey.indexOf(this.input[this.pos]) >= 0) {
              if (optional && this.input[this.pos] != ",") {
                this.pos = start2;
                return null;
              }
              ;
              return this.input.substring(start2, this.pos);
            } else {
              this.pos++;
            }
            ;
          }
          ;
        };
        this.key_equals_value = function() {
          var key = this.key();
          if (this.tryMatch("=")) {
            this.match("=");
            var val = this.value();
            key = key.trim();
            return [key, val];
          } else {
            throw "... = value expected, equals sign missing:" + this.input.substring(this.pos);
          }
          ;
        };
        this.key_value_list = function() {
          var kv = this.key_equals_value();
          this.currentEntry["entryTags"] = {};
          this.currentEntry["entryTags"][kv[0]] = kv[1];
          while (this.tryMatch(",")) {
            this.match(",");
            if (this.tryMatch("}")) {
              break;
            }
            ;
            kv = this.key_equals_value();
            this.currentEntry["entryTags"][kv[0]] = kv[1];
          }
          ;
        };
        this.entry_body = function(d) {
          this.currentEntry = {};
          this.currentEntry["citationKey"] = this.key(true);
          this.currentEntry["entryType"] = d.substring(1);
          if (this.currentEntry["citationKey"] != null) {
            this.match(",");
          }
          this.key_value_list();
          this.entries.push(this.currentEntry);
        };
        this.directive = function() {
          this.match("@");
          return "@" + this.key();
        };
        this.preamble = function() {
          this.currentEntry = {};
          this.currentEntry["entryType"] = "PREAMBLE";
          this.currentEntry["entry"] = this.value_comment();
          this.entries.push(this.currentEntry);
        };
        this.comment = function() {
          this.currentEntry = {};
          this.currentEntry["entryType"] = "COMMENT";
          this.currentEntry["entry"] = this.value_comment();
          this.entries.push(this.currentEntry);
        };
        this.entry = function(d) {
          this.entry_body(d);
        };
        this.alernativeCitationKey = function() {
          this.entries.forEach(function(entry) {
            if (!entry.citationKey && entry.entryTags) {
              entry.citationKey = "";
              if (entry.entryTags.author) {
                entry.citationKey += entry.entryTags.author.split(",")[0] += ", ";
              }
              entry.citationKey += entry.entryTags.year;
            }
          });
        };
        this.bibtex = function() {
          while (this.matchAt()) {
            var d = this.directive();
            this.match("{");
            if (d.toUpperCase() == "@STRING") {
              this.string();
            } else if (d.toUpperCase() == "@PREAMBLE") {
              this.preamble();
            } else if (d.toUpperCase() == "@COMMENT") {
              this.comment();
            } else {
              this.entry(d);
            }
            this.match("}");
          }
          ;
          this.alernativeCitationKey();
        };
      }
      ;
      exports2.toJSON = function(bibtex) {
        var b = new BibtexParser();
        b.setInput(bibtex);
        b.bibtex();
        return b.entries;
      };
      exports2.toBibtex = function(json) {
        var out = "";
        for (var i in json) {
          out += "@" + json[i].entryType;
          out += "{";
          if (json[i].citationKey)
            out += json[i].citationKey + ", ";
          if (json[i].entry)
            out += json[i].entry;
          if (json[i].entryTags) {
            var tags = "";
            for (var jdx in json[i].entryTags) {
              if (tags.length != 0)
                tags += ", ";
              tags += jdx + "= {" + json[i].entryTags[jdx] + "}";
            }
            out += tags;
          }
          out += "}\n\n";
        }
        return out;
      };
    })(typeof exports === "undefined" ? exports["bibtexParse"] = {} : exports);
  }
});
export default require_bibtexParse();
//# sourceMappingURL=bibtex-parse-js.js.map
